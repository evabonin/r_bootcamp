# Gambia
# Gambia, The
#
# Iran (Islamic Republic of)
# Iran, Islamic Rep.
#
# Kyrgyz Republic
# Kyrgyzstan
#
# Lao PDR
# Lao People's Democratic Republic
#
# Micronesia (Federated States of)
# Micronesia, Fed. Sts.
#
# Slovak Republic
# Slovakia
#
# Turkey
# Turkiye
#
# United States
# United States of America
#
# Venezuela (Bolivarian Republic of)
# Venezuela, RB
#
# Viet nam
# Vietnam
#
# Yemen
# Yemen, Rep.
# Getting summary of wide dataset
summary(wb_gbd_wide)
# renaming vars so all are in line
varnames_old <- colnames(wb_gbd_wide)
varnames_old
varnames_new <- c("iso3c", "country", "year","sex","gdp_pc","edu","sui","unem_y","unem_t","pop_t","alc", "drug","depr","sh", "continent", "region")
colnames(wb_gbd_wide) <- varnames_new
# Unique values for Year variable --> will be used for filtering and looping.
#years <- as.list(unique(wb_gbd_wide[c("year")]))
#years <- lapply(years, sort, decreasing = FALSE)
# Imputing missing values - My attempt
# Considerations for imputation:
# - GDP, GDP / capita, compulsory education, total population: same value for male / female as overall. Can use na_mean from imputeTS package.
# - Then, for all vars: Missing years --> interpolation
#
# both <- filter(wb_gbd_wide, wb_gbd_wide$Country == "Aruba" & wb_gbd_wide$Year == "2017" & wb_gbd_wide$Sex == "Both")
# test <- both$`GDP per capita (constant 2015 US$)`
# test
#
#
# # This finally works.But need to save it to the dataset somehow and then turn it into a loop... Can add other columns to the list.
# filter(wb_gbd_wide, wb_gbd_wide$Country == "Aruba" & wb_gbd_wide$Year == "2017" & wb_gbd_wide$Sex != "Both") %>% replace_na(list(`GDP per capita (constant 2015 US$)`= test))
#
#
# # Another attempt, there seems to be a typo around line 230 but I don't know what it is.
#
# wb_gbd_wide %>%
#   group_by(wb_gbd_wide$Country) %>%
#   mutate(
#     wb_gbd_wide$`GDP (constant 2015 US$)` = impute.mean(wb_gbd_wide$`GDP (constant 2015 US$)`)
#   )
# Maybe check this approach: https://stackoverflow.com/questions/71756025/impute-missing-values-within-each-group-based-on-an-equation-in-r
# Imputation using approach by Claude
## Prepare second data set
wb_gbd_wide.both <- wb_gbd_wide %>%
filter(sex == "Both") %>%
select(!sex)
## Join the two data sets because you have to make sure that contry and year
## are correctly merged.
wb_gbd_wide.tmp2 <-
left_join(x = wb_gbd_wide, y = wb_gbd_wide.both,
by = c("country", "year"),
suffix = c("", ".y"))
### finally got this working, I'm sure there is a more elegant way of doing this.
wb_gbd_wide <- wb_gbd_wide.tmp2 %>%
mutate(sui = coalesce(sui, sui.y),
gdp_pc = coalesce(gdp_pc, gdp_pc.y),
edu = coalesce(edu, edu.y),
pop_t = coalesce(pop_t, pop_t.y))
# remove columns with .y suffix
columns_to_remove <- grep("\\.y", names(wb_gbd_wide))
wb_gbd_wide <- wb_gbd_wide[,-columns_to_remove]
# list of countries
countries_wb_gbd <- as.list(unique(wb_gbd_wide[c("country")]))
length(countries_wb_gbd[[1]])
# we have 230 countries
# Counting missing values by country
na_count <- wb_gbd_wide %>%
group_by(country) %>%
dplyr::summarize(count_na = sum(is.na(sui)))
na_count
print(na_count, n=230)
# barplot(na_count$count_na, names.arg = na_count$country, xlab = "Country", ylab = "Count of NA Values", main = "Count of NA Values by Country")
# count the occurrences of each value in count_na[2]
counts <- table(na_count$count_na)
print(counts)
### THIS ONE FOR REPORT
# create a bar plot of the counts
barplot(counts, xlab = "Number of NA Values", ylab = "Count", main = "Counts of NA Values")
# Which countries are completely missing --> remove from dataset
# Which countries are missing missing?
# subset na_count to include only rows where count_na[2] is 15
subset30 <- na_count[na_count$count_na == 30, ]
# print the values of count_na[1] in the subset
print(subset30)
# Which countries are missing 9 values?
# subset na_count to include only rows where count_na[2] is 15
subset9 <- na_count[na_count$count_na == 9, ]
# print the values of count_na[1] in the subset
print(subset9, n=50)
# Exploring the subset9 using code like
# print(filter(df_by_country, country == "Cook Islands"))
# revealed that only three years are available for these countries, and all the suicide data are missing.
# This is because the countries were only in the gdb dataset, not in the WB dataset.
# remove countries with no data on suicide rates
# create a vector of values to exclude
exclude_vec <- as.character(c(subset30[[1]], subset9[[1]]))
exclude_vec
# subset the data frame to exclude rows where the value in the column is in the exclude_vec
wb_gbd_wide <- subset(wb_gbd_wide, !country %in% exclude_vec)
test_countries <- as.list(unique(wb_gbd_wide[c("country")]))
length(test_countries[[1]])
# we have 183 countries
### MISSING VALUES IN TIME SERIES
# Visualising:
library(tidyverse)
library(naniar)
library(ggplot2)
# # plot missing data by country and sex --> too many plots
# wb_gbd_wide %>%
#   group_by(country, sex) %>%
#   ggplot(aes(x = year, y = sui)) +
#   geom_line(aes(color = is.na(sui))) +
#   facet_grid(cols = vars(country), rows = vars(sex)) +
#   scale_color_manual(name = "Missing data", values = c("TRUE" = "red", "FALSE" = "black")) +
#   labs(x = "Year", y = "Suicide rate") +
#   theme_bw()
library(visdat)
library(dplyr)
# getting a plot with a pattern of missing data.
# Note: I used this plot to go back upstream in my code and improve the result by removing countries with missing data on the suicide variable.
# Group the data by country
df_by_country <- wb_gbd_wide %>%
group_by(country, sex) %>%
arrange(year)
# Create a heatmap of missing data using vis_miss()
vis_miss(df_by_country)
###############################################################################
# TRY AND FIX THIS BIT
###############################################################################
#
# # # A Table showing the number of missings per column by country, only for those with missing data.
# library(dplyr)
#
# # This was working yesterday...
# # Group by country and summarize missing values in each column
# df_miss <- df_by_country %>%
#   group_by(country) %>%
#   summarize_at(vars(-group_cols()), ~sum(is.na(.)))
#
# # Filter only those with missing values
# df_miss_filtered <- df_miss %>%
#   filter(rowSums(df_miss[, -1]) > 0)
#
# # View the result
# print(df_miss_filtered, n=250)
#
#
# library(pheatmap)
#
# # Transpose the data frame so that variables are columns and countries are rows
# df_miss_transposed <- t(df_miss_filtered[, -1])
#
# # Create a heatmap with pheatmap
# pdf("../outputs/heatmap_missings.pdf")
#
# pheatmap(df_miss_transposed,
#          color = colorRampPalette(c("yellow", "purple"))(100),
#          cluster_cols = TRUE)
# dev.off()
# The heatmap shows the pattern of missing values across the variables and countries. Each row in the heatmap corresponds to a variable, and each column corresponds to a country. The cells in the heatmap are colored according to the proportion of missing values for that variable in that country, with white cells indicating no missing values, and blue cells indicating high proportions of missing values.
#
# Interpreting the heatmap involves looking for patterns in the missing data across the different variables and countries. Here are some general guidelines:
#
#   Look for variables that have a high proportion of missing values across many countries. These variables may be difficult to work with, as they may limit the scope of analysis or introduce bias.
#   Look for countries that have a high proportion of missing values across many variables. These countries may be underrepresented in the analysis or may require imputation methods to handle the missing data.
#   Look for patterns of missingness that may be related to other variables or factors. For example, if a country has a high proportion of missing values for income and education variables, it may be an indication of socioeconomic disparities or differences in data collection methods.
# In general, interpreting missing data can be complex and may require additional information about the variables and countries in question. The heatmap can provide a useful visual summary of the missing data patterns, but it should be used in conjunction with other analyses and considerations.
###############################################################################
###############################################################################
# Replace where it's missing in the series.
# https://stackoverflow.com/questions/50648800/ggplot-plotting-timeseries-data-with-missing-values
# na_locf() from package zoo
library(dplyr)
library(imputeTS)
# Impute missing values using median by group (country, sex). There may be a more efficient way of doing this
df_imputed <- df_by_country %>%
mutate(gdp_pc = median(gdp_pc, na.rm = TRUE),
edu = median(edu, na.rm = TRUE),
sui = median(sui, na.rm = TRUE),
unem_y = median(unem_y, na.rm = TRUE),
unem_t = median(unem_t, na.rm = TRUE),
pop_t = median(pop_t, na.rm = TRUE),
alc = median(alc, na.rm = TRUE),
drug = median(drug, na.rm = TRUE),
depr = median(depr, na.rm = TRUE),
sh = median(sh, na.rm = TRUE))
summary(df_by_country)
summary(df_imputed)
# This approach isn't all that successful --> imputing median by region
df_by_region <- wb_gbd_wide %>%
group_by(region, sex) %>%
arrange(year)
# Repeating imputation by region Obviously not the correct thing to do!
df_imputed2 <- df_by_region %>%
mutate(gdp_pc = median(gdp_pc, na.rm = TRUE),
edu = median(edu, na.rm = TRUE),
sui = median(sui, na.rm = TRUE),
unem_y = median(unem_y, na.rm = TRUE),
unem_t = median(unem_t, na.rm = TRUE),
pop_t = median(pop_t, na.rm = TRUE),
alc = median(alc, na.rm = TRUE),
drug = median(drug, na.rm = TRUE),
depr = median(depr, na.rm = TRUE),
sh = median(sh, na.rm = TRUE))
summary(df_by_country)
summary(df_imputed2)
# And finally by continent
df_by_continent <- wb_gbd_wide %>%
group_by(continent, sex) %>%
arrange(year)
# Repeating imputation by region Obviously not the correct thing to do!
df_imputed3 <- df_by_continent %>%
mutate(gdp_pc = median(gdp_pc, na.rm = TRUE),
edu = median(edu, na.rm = TRUE),
sui = median(sui, na.rm = TRUE),
unem_y = median(unem_y, na.rm = TRUE),
unem_t = median(unem_t, na.rm = TRUE),
pop_t = median(pop_t, na.rm = TRUE),
alc = median(alc, na.rm = TRUE),
drug = median(drug, na.rm = TRUE),
depr = median(depr, na.rm = TRUE),
sh = median(sh, na.rm = TRUE))
summary(df_by_country)
summary(df_imputed3)
wb_gbd_wide <- df_imputed3
#write_xlsx(df_imputed3,"../data/wb_gbd_wide.xlsx")
### MISSING VALUES IN TIME SERIES
# Visualising:
library(tidyverse)
library(naniar)
library(ggplot2)
# # plot missing data by country and sex --> too many plots
# wb_gbd_wide %>%
#   group_by(country, sex) %>%
#   ggplot(aes(x = year, y = sui)) +
#   geom_line(aes(color = is.na(sui))) +
#   facet_grid(cols = vars(country), rows = vars(sex)) +
#   scale_color_manual(name = "Missing data", values = c("TRUE" = "red", "FALSE" = "black")) +
#   labs(x = "Year", y = "Suicide rate") +
#   theme_bw()
library(visdat)
library(dplyr)
# getting a plot with a pattern of missing data.
# Note: I used this plot to go back upstream in my code and improve the result by removing countries with missing data on the suicide variable.
# Group the data by country
df_by_country <- wb_gbd_wide %>%
group_by(country, sex) %>%
arrange(year)
# Create a heatmap of missing data using vis_miss()
vis_miss(df_by_country)
###############################################################################
# TRY AND FIX THIS BIT
###############################################################################
#
# # # A Table showing the number of missings per column by country, only for those with missing data.
# library(dplyr)
#
# # This was working yesterday...
# # Group by country and summarize missing values in each column
# df_miss <- df_by_country %>%
#   group_by(country) %>%
#   summarize_at(vars(-group_cols()), ~sum(is.na(.)))
#
# # Filter only those with missing values
# df_miss_filtered <- df_miss %>%
#   filter(rowSums(df_miss[, -1]) > 0)
#
# # View the result
# print(df_miss_filtered, n=250)
#
#
# library(pheatmap)
#
# # Transpose the data frame so that variables are columns and countries are rows
# df_miss_transposed <- t(df_miss_filtered[, -1])
#
# # Create a heatmap with pheatmap
# pdf("../outputs/heatmap_missings.pdf")
#
# pheatmap(df_miss_transposed,
#          color = colorRampPalette(c("yellow", "purple"))(100),
#          cluster_cols = TRUE)
# dev.off()
# The heatmap shows the pattern of missing values across the variables and countries. Each row in the heatmap corresponds to a variable, and each column corresponds to a country. The cells in the heatmap are colored according to the proportion of missing values for that variable in that country, with white cells indicating no missing values, and blue cells indicating high proportions of missing values.
#
# Interpreting the heatmap involves looking for patterns in the missing data across the different variables and countries. Here are some general guidelines:
#
#   Look for variables that have a high proportion of missing values across many countries. These variables may be difficult to work with, as they may limit the scope of analysis or introduce bias.
#   Look for countries that have a high proportion of missing values across many variables. These countries may be underrepresented in the analysis or may require imputation methods to handle the missing data.
#   Look for patterns of missingness that may be related to other variables or factors. For example, if a country has a high proportion of missing values for income and education variables, it may be an indication of socioeconomic disparities or differences in data collection methods.
# In general, interpreting missing data can be complex and may require additional information about the variables and countries in question. The heatmap can provide a useful visual summary of the missing data patterns, but it should be used in conjunction with other analyses and considerations.
###############################################################################
###############################################################################
# Replace where it's missing in the series.
# https://stackoverflow.com/questions/50648800/ggplot-plotting-timeseries-data-with-missing-values
# na_locf() from package zoo
library(dplyr)
library(imputeTS)
# Impute missing values using median by group (country, sex). There may be a more efficient way of doing this
df_imputed <- df_by_country %>%
mutate(gdp_pc = median(gdp_pc, na.rm = TRUE),
edu = median(edu, na.rm = TRUE),
sui = median(sui, na.rm = TRUE),
unem_y = median(unem_y, na.rm = TRUE),
unem_t = median(unem_t, na.rm = TRUE),
pop_t = median(pop_t, na.rm = TRUE),
alc = median(alc, na.rm = TRUE),
drug = median(drug, na.rm = TRUE),
depr = median(depr, na.rm = TRUE),
sh = median(sh, na.rm = TRUE))
summary(df_by_country)
summary(df_imputed)
# This approach isn't all that successful --> imputing median by region
df_by_region <- wb_gbd_wide %>%
group_by(region, sex) %>%
arrange(year)
# Repeating imputation by region Obviously not the correct thing to do!
df_imputed2 <- df_by_region %>%
mutate(gdp_pc = median(gdp_pc, na.rm = TRUE),
edu = median(edu, na.rm = TRUE),
sui = median(sui, na.rm = TRUE),
unem_y = median(unem_y, na.rm = TRUE),
unem_t = median(unem_t, na.rm = TRUE),
pop_t = median(pop_t, na.rm = TRUE),
alc = median(alc, na.rm = TRUE),
drug = median(drug, na.rm = TRUE),
depr = median(depr, na.rm = TRUE),
sh = median(sh, na.rm = TRUE))
summary(df_by_country)
summary(df_imputed2)
# And finally by continent
df_by_continent <- wb_gbd_wide %>%
group_by(continent, sex) %>%
arrange(year)
# Repeating imputation by region Obviously not the correct thing to do!
df_imputed3 <- df_by_continent %>%
mutate(gdp_pc = median(gdp_pc, na.rm = TRUE),
edu = median(edu, na.rm = TRUE),
sui = median(sui, na.rm = TRUE),
unem_y = median(unem_y, na.rm = TRUE),
unem_t = median(unem_t, na.rm = TRUE),
pop_t = median(pop_t, na.rm = TRUE),
alc = median(alc, na.rm = TRUE),
drug = median(drug, na.rm = TRUE),
depr = median(depr, na.rm = TRUE),
sh = median(sh, na.rm = TRUE))
summary(df_by_country)
summary(df_imputed3)
wb_gbd_wide <- df_imputed3
#write_xlsx(df_imputed3,"../data/wb_gbd_wide.xlsx")
summary(df_imputed3)
summary(suicide_final)
suicide_final <- df_imputed3
summary(suicide_final)
sui_country <- suicide_final %>% group_by(country, year) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country
sui_country <- suicide_final %>%
filter(sex = "Both") %>%
group_by(country, year) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country <- suicide_final %>%
filter(sex == "Both") %>%
group_by(country, year) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country
sui_country <- suicide_final %>%
filter(sex == "Both") %>%
group_by(country, year, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country
sui_country <- suicide_final %>%
filter(sex != "Both") %>%
group_by(country, year, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country
suicide_final$year <- str(suicide_final$year)
summary(suicide_final)
View(suicide_final)
suicide_final <- df_imputed3
str(suicide_final$year)
summary(suicide_final)
suicide_final$year <- as.Date(suicide_final$year, format = "%y")
suicide_final$year <- as.Date(suicide_final$year, format = "%y", origin = "0000")
summary(suicide_final)
str(suicide_final%year)
str(suicide_final$year)
View(suicide_final)
suicide_final$year <- as.Date(suicide_final$year, format = "%y", origin = "0000-01-01")
str(suicide_final$year)
yr <- as.Date(as.character(suicide_final$year), format = "%y")
suicide_final$year <- year(yr)
str(suicide_final$year)
suicide_final <- df_imputed3
library(lubridate)
yr <- as.Date(as.character(suicide_final$year), format = "%y")
suicide_final$year1 <- year(yr)
str(suicide_final$year1)
summary(suicide_final)
suicide_final$year1 <- ymb(paste0(suicide_final$year, "-01-01"))
library(lubridate)
suicide_final$year1 <- ymd(paste0(suicide_final$year, "-01-01"))
str(suicide_final$year1)
summary(suicide_final)
# Describe data set: summary
summary(suicide_final)
# Summarise suicide data by country, male and female separately
sui_country <- suicide_final %>%
filter(sex != "Both") %>%
group_by(country, year, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country
sui_country <- suicide_final %>%
filter(sex != "Both") %>%
group_by(country, year1, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country
# Summarise suicide data by continent
sui_continent <- suicide_final %>%
group_by(continent, year1, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_continent
# Show countries with the highest suicide rates over time
sui_country_time <- suicide_final %>%
group_by(country, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country_time
sui_country_time_sorted <- sui_country_time[order(sui_country_time$mean_sui),]
print(sui_country_time_sorted)
sui_country_time_sorted <- sui_country_time[order(sui_country_time$mean_sui, decreasing = TRUE),]
print(sui_country_time_sorted)
print(sui_country_time_sorted, n = 50)
sui_country <- suicide_final %>%
group_by(country, year1, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
print(sui_country, n=50)
# Show countries with the highest suicide rates over time
sui_country_time <- suicide_final %>%
group_by(country, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country_time
sui_country_time_sorted <- sui_country_time[order(sui_country_time$mean_sui, decreasing = TRUE),]
print(sui_country_time_sorted, n = 50)
sui_continent_sorted <- sui_continent[order(sui_continent$mean_sui, decreasing = TRUE),]
print(sui_continent_sorted, n=10)
# Show countries with the highest suicide rates over time
sui_country_time <- suicide_final %>%
group_by(country, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_country_time
sui_country_time_sorted <- sui_country_time[order(sui_country_time$mean_sui, decreasing = TRUE),]
print(sui_country_time_sorted, n = 50)
# Summarise suicide data by continent
sui_continent <- suicide_final %>%
group_by(continent, year1, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_continent_sorted <- sui_continent[order(sui_continent$mean_sui, decreasing = TRUE),]
print(sui_continent_sorted, n=10)
# Summarise suicide data by continent
sui_continent <- suicide_final %>%
group_by(continent, sex) %>%
summarise(mean_sui=mean(sui),
.groups = 'drop')
sui_continent_sorted <- sui_continent[order(sui_continent$mean_sui, decreasing = TRUE),]
print(sui_continent_sorted, n=10)
sui_continent_sorted <- sui_continent %>%
filter(sex == "Both") %>%
arrange(mean_sui)
print(sui_continent_sorted, n=10)
sui_continent_sorted <- sui_continent %>%
filter(sex == "Both") %>%
arrange(mean_sui, descending == TRUE)
sui_continent_sorted <- sui_continent %>%
filter(sex == "Both") %>%
arrange(desc(mean_sui))
print(sui_continent_sorted, n=10)
